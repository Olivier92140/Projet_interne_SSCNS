[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Classification non supervisÃ©e",
    "section": "",
    "text": "External link to Quarto website\nR example\nPython example ğŸ"
  },
  {
    "objectID": "index.html#quarto",
    "href": "index.html#quarto",
    "title": "Classification non supervisÃ©e",
    "section": "",
    "text": "External link to Quarto website\nR example\nPython example ğŸ"
  },
  {
    "objectID": "modeles/mod_kmeans.html",
    "href": "modeles/mod_kmeans.html",
    "title": "Algorithme des K-means",
    "section": "",
    "text": "Lâ€™algorithme des K-means appelÃ©es aussi mÃ©thode des centres mobiles (ou algorithme de Lloyd) a pour but de fournir une partition. On considÃ¨re que les observations x= {ğ‘¥â‚, .., ğ‘¥â‚™} sont dÃ©crites par p variables (ğ‘¥â‚™ appartient Ã  â„áµ–) et que lâ€™espace est munie est de la mÃ©trique (gÃ©nÃ©ralement distance euclidienne).Pour simplifier les notations,on supposera que chaque observation a le mÃªme poids."
  },
  {
    "objectID": "modeles/mod_kmeans.html#introduction",
    "href": "modeles/mod_kmeans.html#introduction",
    "title": "Algorithme des K-means",
    "section": "",
    "text": "Lâ€™algorithme des K-means appelÃ©es aussi mÃ©thode des centres mobiles (ou algorithme de Lloyd) a pour but de fournir une partition. On considÃ¨re que les observations x= {ğ‘¥â‚, .., ğ‘¥â‚™} sont dÃ©crites par p variables (ğ‘¥â‚™ appartient Ã  â„áµ–) et que lâ€™espace est munie est de la mÃ©trique (gÃ©nÃ©ralement distance euclidienne).Pour simplifier les notations,on supposera que chaque observation a le mÃªme poids."
  },
  {
    "objectID": "modeles/mod_kmeans.html#algorithme-de-lloyd-k-means",
    "href": "modeles/mod_kmeans.html#algorithme-de-lloyd-k-means",
    "title": "Algorithme des K-means",
    "section": "Algorithme de Lloyd (k-means)",
    "text": "Algorithme de Lloyd (k-means)\n\nAlgorithme des k-means\nLa mÃ©thode des centres mobiles a pour but de fournir une partition de x= {ğ‘¥â‚, .., ğ‘¥â‚™}.\n\nPrincipe : Pour lâ€™ensemble dâ€™observations ğ‘¥ = {ğ‘¥â‚, .., ğ‘¥â‚™}, on suppose quâ€™il existe\nğ¶á´· = {ğ¶â‚, .., ğ¶â‚–} tel que ğ‘¥ = â‹ƒâ‚–â‚Œâ‚á´· ğ¶â‚– est disjoint\n\n\nEtape 1. On commence par choisir K observations diffÃ©rentes : {Î¼â‚, .., Î¼â‚–}\nEtape 2. On rÃ©alise itÃ©rativement une succession ces actions:\n\nPour chaque observation x= {ğ‘¥â‚, .., ğ‘¥â‚™} on trouve son centre (barycentre) le plus proche pour crÃ©er ğ¶â‚– = {ensemble dâ€™observations les plus proches du centre Î¼â‚–}\nDans chaque nouvelle classe ğ¶â‚– on dÃ©finit le nouveau centre de classe Î¼â‚– comme Ã©tant le barycentre de ğ¶â‚–.\n\nEtape 3. on rÃ©itÃ¨re lâ€™Ã©tape 1.\n\n\n\nRemarques\n\nLâ€™algorithme sâ€™arrÃªte lorsque la partition des classes ne change plus (critÃ¨re de convergence)\nlâ€™algorithme ne sâ€™applique que sur des donnÃ©es quantitatives"
  },
  {
    "objectID": "modeles/mod_kmeans.html#exemple-1",
    "href": "modeles/mod_kmeans.html#exemple-1",
    "title": "Algorithme des K-means",
    "section": "Exemple 1",
    "text": "Exemple 1\nVoici un exemple de script R utilisant lâ€™algorithme k-means pour trouver les classes (les clusters) des donnÃ©es x={1, 2, 9, 12, 20} avec les barycentres Âµâ‚=1 et Î¼â‚‚=7\n\n# donnÃ©es\nk1 &lt;- 2\nx1    &lt;- c(1, 2, 9, 12, 20)\ninit1 &lt;- matrix(c(1, 7), ncol = 1)  # centres initiaux\n\n# k-means\nres1  &lt;- kmeans(x1, centers = init1, iter.max = 10)\n\n# regroupement des donnÃ©es par classe\nclasses1 &lt;- split(x1, res1$cluster)\n\n# affichage des classes et de leurs Ã©lÃ©ments\ncat(\"\\nÃ‰lÃ©ments par classe :\\n\")\n\n\nÃ‰lÃ©ments par classe :\n\nfor (i in seq_along(classes1)) {\n  cat(sprintf(\"Classe %d : %s\\n\", i, paste(classes1[[i]], collapse = \", \")))\n}\n\nClasse 1 : 1, 2\nClasse 2 : 9, 12, 20\n\n# affichage des centres finaux\ncat(\"Centres finaux :\\n\")\n\nCentres finaux :\n\nprint(res1$centers)\n\n      [,1]\n1  1.50000\n2 13.66667\n\n\nlâ€™inertie intra classe est Ã©gale Ã  :\n\ntotal_inertia_alt1 &lt;- sum(res1$withinss)\nprint(total_inertia_alt1)\n\n[1] 65.16667"
  },
  {
    "objectID": "modeles/mod_kmeans.html#exemple-2",
    "href": "modeles/mod_kmeans.html#exemple-2",
    "title": "Algorithme des K-means",
    "section": "Exemple 2",
    "text": "Exemple 2\nVoici un exemple de script R utilisant lâ€™algorithme k-means pour trouver les classes (les clusters) des donnÃ©es x={1, 2, 9, 12, 20} avec les barycentres Âµ1 =1, Âµ2 =12 et Âµ3 =20\n\n# donnÃ©es\nk2 &lt;- 3\nx2 &lt;- c(1, 2, 9, 12, 20)\ninit2 &lt;- matrix(c(1, 12, 20), ncol = 1)  # centres initiaux\n\n# k-means\nres2  &lt;- kmeans(x2, centers = init2, iter.max = 10)\n\n# regroupement des donnÃ©es par classe\nclasses2 &lt;- split(x2, res2$cluster)\n\n# affichage des classes et de leurs Ã©lÃ©ments\ncat(\"\\nÃ‰lÃ©ments par classe :\\n\")\n\n\nÃ‰lÃ©ments par classe :\n\nfor (i in seq_along(classes2)) {\n  cat(sprintf(\"Classe %d : %s\\n\", i, paste(classes2[[i]], collapse = \", \")))\n}\n\nClasse 1 : 1, 2\nClasse 2 : 9, 12\nClasse 3 : 20\n\n# affichage des centres finaux\ncat(\"Centres finaux :\\n\")\n\nCentres finaux :\n\nprint(res2$centers)\n\n  [,1]\n1  1.5\n2 10.5\n3 20.0"
  },
  {
    "objectID": "modeles/mod_kmeans.html#propriÃ©tÃ©s",
    "href": "modeles/mod_kmeans.html#propriÃ©tÃ©s",
    "title": "Algorithme des K-means",
    "section": "PropriÃ©tÃ©s",
    "text": "PropriÃ©tÃ©s\n\nInertie intra-classe\n\nLâ€™inertie intra-classe de x = {x1,..,xn} par rapport Ã  la partition C ={C1,..,CK} et les centres des classes dans Âµ = {Âµ1,..,ÂµK} sâ€™Ã©crit: IW = d2(xi, Âµk) k=1xiâˆˆCk Notons-la IW(C,Âµ) Ã  partir de maintenant.\n\nNotons-la IW(C,Âµ) Ã  partir de maintenant.\nlâ€™inertie intra classe est Ã©gale Ã  :\n\ntotal_inertia_alt2 &lt;- sum(res2$withinss)\nprint(total_inertia_alt2)\n\n[1] 5"
  },
  {
    "objectID": "modeles/mod_kmeans.html#exemple-3",
    "href": "modeles/mod_kmeans.html#exemple-3",
    "title": "Algorithme des K-means",
    "section": "Exemple 3",
    "text": "Exemple 3\nVoici un exemple de script R utilisant lâ€™algorithme k-means pour trouver les classes (les clusters) des donnÃ©es x={1, 2, 9, 12, 20} avec les barycentres Âµ1 =1, Âµ2 =9, Âµ3 =12 et Âµ4 =20.\n\n# donnÃ©es\nx3 &lt;- c(1, 2, 9, 12, 20)\ninit3 &lt;- matrix(c(1, 9, 12, 20), ncol = 1)  # centres initiaux\n\n# k-means\nres3 &lt;- kmeans(x3, centers = init3, iter.max = 10)\n\n# regroupement des donnÃ©es par classe\nclasses3 &lt;- split(x3, res3$cluster)\n\n# affichage des classes et de leurs Ã©lÃ©ments\ncat(\"\\nÃ‰lÃ©ments par classe :\\n\")\n\n\nÃ‰lÃ©ments par classe :\n\nfor (i in seq_along(classes3)) {\n  cat(sprintf(\"Classe %d : %s\\n\", i, paste(classes3[[i]], collapse = \", \")))\n}\n\nClasse 1 : 1, 2\nClasse 2 : 9\nClasse 3 : 12\nClasse 4 : 20\n\n# affichage des centres finaux\ncat(\"Centres finaux :\\n\")\n\nCentres finaux :\n\nprint(res3$centers)\n\n  [,1]\n1  1.5\n2  9.0\n3 12.0\n4 20.0\n\n\nlâ€™inertie intra classe est Ã©gale Ã  :\n\ntotal_inertia_alt3 &lt;- sum(res3$withinss)\nprint(total_inertia_alt3)\n\n[1] 0.5"
  },
  {
    "objectID": "modeles/mod_kmeans.html#mÃ©thode-du-coude",
    "href": "modeles/mod_kmeans.html#mÃ©thode-du-coude",
    "title": "Algorithme des K-means",
    "section": "MÃ©thode du coude",
    "text": "MÃ©thode du coude\n\n# vecteur de valeurs de k Ã  tester\nks    &lt;- 2:4\n\n# prÃ©-allocation dâ€™un vecteur pour stocker lâ€™inertie totale\ninertias &lt;- c(total_inertia_alt1, total_inertia_alt2, total_inertia_alt3)\n\n# tracÃ© de la courbe inertie vs k\nplot(ks, inertias,\n     type = \"b\",                             # points reliÃ©s par des segments\n     pch  = 19,                              # symbole plein pour les points\n     xlab = \"Nombre de clusters (k)\",\n     ylab = \"Inertie intra-classe totale\",\n     main = \"MÃ©thode du coude pour le choix de k\")"
  }
]